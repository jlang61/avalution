package merkledb

import (
	"testing"

	"github.com/ava-labs/avalanchego/ids"
	"github.com/ava-labs/avalanchego/utils/maybe"
	"github.com/stretchr/testify/require"
)

var (
	encodeDBNodeTests_disk = []struct {
		name          string
		n             *dbNode
		expectedBytes []byte
	}{
		{
			name: "empty node",
			n: &dbNode{
				children: make(map[byte]*child),
				//diskAddr: diskAddress{offset: 1, size: 2},
			},
			expectedBytes: []byte{
				0x00, // value.HasValue()
				0x00, // len(children)
			},
		},
		{
			name: "has value",
			n: &dbNode{
				value:    maybe.Some([]byte("value")),
				children: make(map[byte]*child),
				//diskAddr: diskAddress{offset: 1, size: 2},
			},
			expectedBytes: []byte{
				0x01,                    // value.HasValue()
				0x05,                    // len(value.Value())
				'v', 'a', 'l', 'u', 'e', // value.Value()
				0x00, // len(children)
			},
		},
		{
			name: "1 child",
			n: &dbNode{
				value: maybe.Some([]byte("value")),
				children: map[byte]*child{
					0: {
						compressedKey: ToKey([]byte{0}),
						id: ids.ID{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
							0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
							0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						hasValue: true,
						diskAddr: diskAddress{offset: 1, size: 2},
					},
				},
			},
			expectedBytes: []byte{
				0x01,                    // value.HasValue()
				0x05,                    // len(value.Value())
				'v', 'a', 'l', 'u', 'e', // value.Value()
				0x01, // len(children)
				0x00, // children[0].index
				0x08, // len(children[0].compressedKey)
				0x00, // children[0].compressedKey
				// children[0].id
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
				0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
				// disk addr
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x01, // children[0].hasValue
			},
		},
		{
			name: "2 children",
			n: &dbNode{
				value: maybe.Some([]byte("value")),
				children: map[byte]*child{
					0: {
						compressedKey: ToKey([]byte{0}),
						id: ids.ID{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
							0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
							0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						hasValue: true,
						diskAddr: diskAddress{offset: 1, size: 2},
					},
					1: {
						compressedKey: ToKey([]byte{1}),
						id: ids.ID{
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
							0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
							0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
						},
						hasValue: false,
						diskAddr: diskAddress{offset: 3, size: 4},
					},
				},
			},
			expectedBytes: []byte{
				0x01,                    // value.HasValue()
				0x05,                    // len(value.Value())
				'v', 'a', 'l', 'u', 'e', // value.Value()
				0x02, // len(children)
				// child 0
				0x00,                   // children[0].index
				0x08,                   // len(children[0].compressedKey)
				0x00,                   // children[0].compressedKey
				0x00, 0x01, 0x02, 0x03, // children[0].id
				0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0a, 0x0b,
				0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13,
				0x14, 0x15, 0x16, 0x17,
				0x18, 0x19, 0x1a, 0x1b,
				0x1c, 0x1d, 0x1e, 0x1f,
				// disk addr
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x02,
				0x01, // children[0].hasValue
				// child 1
				0x01,                   // children[1].index
				0x08,                   // len(children[1].compressedKey)
				0x01,                   // children[1].compressedKey
				0x10, 0x11, 0x12, 0x13, // children[1].id
				0x14, 0x15, 0x16, 0x17,
				0x18, 0x19, 0x1a, 0x1b,
				0x1c, 0x1d, 0x1e, 0x1f,
				0x20, 0x21, 0x22, 0x23,
				0x24, 0x25, 0x26, 0x27,
				0x28, 0x29, 0x2a, 0x2b,
				0x2c, 0x2d, 0x2e, 0x2f,
				// disk addr
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x04,
				0x00, // children[1].hasValue
			},
		},
		{
			name: "16 children",
			n: func() *dbNode {
				n := &dbNode{
					value:    maybe.Some([]byte("value")),
					children: make(map[byte]*child),
				}
				for i := byte(0); i < 16; i++ {
					n.children[i] = &child{
						compressedKey: ToKey([]byte{i}),
						id: ids.ID{
							0x00 + i, 0x01 + i, 0x02 + i, 0x03 + i,
							0x04 + i, 0x05 + i, 0x06 + i, 0x07 + i,
							0x08 + i, 0x09 + i, 0x0a + i, 0x0b + i,
							0x0c + i, 0x0d + i, 0x0e + i, 0x0f + i,
							0x10 + i, 0x11 + i, 0x12 + i, 0x13 + i,
							0x14 + i, 0x15 + i, 0x16 + i, 0x17 + i,
							0x18 + i, 0x19 + i, 0x1a + i, 0x1b + i,
							0x1c + i, 0x1d + i, 0x1e + i, 0x1f + i,
						},
						diskAddr: diskAddress{offset: int64(i + 1), size: int64(i + 1)},
						hasValue: i%2 == 0,
					}
				}
				return n
			}(),
			expectedBytes: []byte{
				0x01,                    // value.HasValue()
				0x05,                    // len(value.Value())
				'v', 'a', 'l', 'u', 'e', // value.Value()
				0x10, // len(children)
				0x00, // children[0].index
				0x08, // len(children[0].compressedKey)
				0x00, // children[0].compressedKey
				// children[0].id
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
				0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
				0x00, 0x00, 0x00, 0x00, // disk address
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x01,
				0x01, // children[0].hasValue
				0x01, // children[1].index
				0x08, // len(children[1].compressedKey)
				0x01, // children[1].compressedKey
				// children[1].id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
				0x00, 0x00, 0x00, 0x00, // disk address
				0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x02,
				0x00, // children[1].hasValue
				0x02, // children[2].index
				0x08, // len(children[2].compressedKey)
				0x02, // children[2].compressedKey
				// children[2].id
				0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
				0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11,
				0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
				0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x03, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x03,
				0x01, // children[2].hasValue
				0x03, // children[3].index
				0x08, // len(children[3].compressedKey)
				0x03, // children[3].compressedKey
				// children[3].id
				0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
				0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,
				0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
				0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,
				0x00, 0x00, 0x00, 0x00, // disk address
				0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x04,
				0x00, // children[3].hasValue
				0x04, // children[4].index
				0x08, // len(children[4].compressedKey)
				0x04, // children[4].compressedKey
				// children[4].id
				0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
				0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
				0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
				0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x05, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x05,
				0x01, // children[4].hasValue
				0x05, // children[5].index
				0x08, // len(children[5].compressedKey)
				0x05, // children[5].compressedKey
				// children[5].id
				0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c,
				0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
				0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
				0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
				0x00, 0x00, 0x00, 0x00, // disk address
				0x00, 0x00, 0x00, 0x06,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x06,
				0x00, // children[5].hasValue
				0x06, // children[6].index
				0x08, // len(children[6].compressedKey)
				0x06, // children[6].compressedKey
				// children[6].id
				0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
				0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
				0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
				0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x07, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x07,
				0x01, // children[6].hasValue
				0x07, // children[7].index
				0x08, // len(children[7].compressedKey)
				0x07, // children[7].compressedKey
				// children[7].id
				0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
				0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
				0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
				0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x08, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x08,
				0x00, // children[7].hasValue
				0x08, // children[8].index
				0x08, // len(children[8].compressedKey)
				0x08, // children[8].compressedKey
				// children[8].id
				0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
				0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
				0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x09, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x09,
				0x01, // children[8].hasValue
				0x09, // children[9].index
				0x08, // len(children[9].compressedKey)
				0x09, // children[9].compressedKey
				// children[9].id
				0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
				0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0a, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0a,
				0x00, // children[9].hasValue
				0x0a, // children[10].index
				0x08, // len(children[10].compressedKey)
				0x0a, // children[10].compressedKey
				// children[10].id
				0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11,
				0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
				0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21,
				0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0b, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0b,
				0x01, // children[10].hasValue
				0x0b, // children[11].index
				0x08, // len(children[11].compressedKey)
				0x0b, // children[11].compressedKey
				// children[11].id
				0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,
				0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
				0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,
				0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0c, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0c,
				0x00, // children[11].hasValue
				0x0c, // children[12].index
				0x08, // len(children[12].compressedKey)
				0x0c, // children[12].compressedKey
				// children[12].id
				0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
				0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
				0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
				0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0d, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0d,
				0x01, // children[12].hasValue
				0x0d, // children[13].index
				0x08, // len(children[13].compressedKey)
				0x0d, // children[13].compressedKey
				// children[13].id
				0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
				0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
				0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
				0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0e, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0e,
				0x00, // children[13].hasValue
				0x0e, // children[14].index
				0x08, // len(children[14].compressedKey)
				0x0e, // children[14].compressedKey
				// children[14].id
				0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
				0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
				0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
				0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0f, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x0f,
				0x01, // children[14].hasValue
				0x0f, // children[15].index
				0x08, // len(children[15].compressedKey)
				0x0f, // children[15].compressedKey
				// children[15].id
				0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
				0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
				0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
				0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x10, // disk address
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x10,
				0x00, // children[15].hasValue
			},
		},
	}
)

func TestEncodeDBNode_disk(t *testing.T) {
	for _, test := range encodeDBNodeTests_disk {
		t.Run(test.name, func(t *testing.T) {
			bytes := encodeDBNode_disk(test.n)
			require.Equal(t, test.expectedBytes, bytes)
		})
	}
}

func TestDecodeDBNode_disk(t *testing.T) {
	for _, test := range encodeDBNodeTests_disk {
		t.Run(test.name, func(t *testing.T) {
			require := require.New(t)

			var n dbNode
			require.NoError(decodeDBNode_disk(test.expectedBytes, &n))
			require.Equal(test.n, &n)
		})
	}
}
